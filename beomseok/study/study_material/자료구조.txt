array
데이터가 많아지고 관리가 필요할때
특징 : 고정된 크기를 가지고 있어
배열안에 저장되어 있는 원소들이 인덱스에 따라 값이 저장되어있다
데이터를 검색하거나 수정할때 빠르다

list
특징 : 순서가 있는 데이터의 모임
배열의 단점을 해결하는 자료구조
배열의 단점 : 미리 크기를 지정해야해 -> 추가 삭제가 어려워
배열에서의 idx : 배열의 데이터를 판별할수있는 유일한 식별자
리스트에서의 idx : 몇번째 데이터인지 정도를 판단

arraylist
배열의 사용해서 리스트를 구현한 것
특징 : 크기를 지정하지 않아도 되고 데이터 검색은 빨라
추가삭제가 상대적으로 좀 느려
순차적일 필요가 없어


linkedlist
연결성으로 구현한 리스트
순차적
데이터값아고 그 다음데이터 주소를 연결하는 방식
배열이랑 다르게 논리적 저장위치와 물리적 저장위치가 다르다.
논리적 위치 : list.get(0), list.get(1) -> 내 머리속에 어떻게 저장이 되냐
물리적 위치 : ox123, ox124 -> 디스크에 어떻게 저장이 되냐

stack
시간의 순서에 따라 쌓인 데어터 형태의 자료구조
후입선출 lifo
push, pop, peek, size, ...
활용 : 웹브라우저 뒤로가기
후위표기법
괄호문제

queue
선입선출
offer, poll, peek
활용 -> 캐시, 대기열, bfs(넓이 우선 탐색)

dequeue
양방향 큐
양쪽에서 삽입삭제가 가능한 구조
스택하고 큐의 연산을 모두 지원해
offerfirst, offerlast, pollfirst, polllast 

map
key와 value의 한쌍으로 이루어지는 데이터 집합
key : 중복을 하용하지 않고 순서를 보장하지 않아
데이터 검색이 매우 빨라 -> 배열에서 인덱스 사용하는 것처럼 데이터를 바로 가져올 수 있기 때문에
Map<String, Integer> map = new HashMap<>();

set
집합 -> 데이터의 집합
순서가 없고 중복을 허용하지 않아
검색속도가 빠르고
인덱스 존재하지 않는다
그렇기 때문에 iterator를 사용해
iterator : 객체, 자료구조 내부요소를 순회하는 객체

hashset : 해시값을 기준으로 정렬 -> 순서를 보장하지 않고
null도 허용학소, treeset보다 삽입삭제가 빨라

treeset : 데이터들이 오름차순으로 정렬
삽입이나 삭제에는 오래걸려, 검색이나 정렬은 빨라

linkedhashset : 순서를 보장

tree
하나의 root 노드를 가진다
루트 노드는 0개 이상의 자식 노드들을 가지고 있고 그 자식들도 0개 이상의 자식들을 가지고 있는 구조
비선형 자료구조, 계층형
순환이 되면 안된다
노드와 간선으로 이루어져 있다

graph
순환이 가능해, 근데 비순환도 가능하다
그래프가 트리를 포함한다

trie
검색을 빠르게 하고 싶을때
사전이라고 생각하면 돼
트리같은 자료구조를 가진다
				root 0
		a 2					b 2
p 1			c 1		d 1				e 1
루트는 아무런 값을 가지지 않아
a 옆의 숫자가 2인 이유는 a로 시작하는 글자가 2개라는 뜻
단어 : ap, ac, bd, be

원래는 ap를 찾으려면 전체를 다 뒤져야해(브루트포스)
근데 trie는 a로 들어가고 자식노드중에 p찾고 이런식으로 하면 됨
그렇다면 그냥 있다 없다로 true false로 하면 안돼?
그럴바엔 안넣는게 낫다.
